name: 2 Time (Independent)

on:
  schedule:
    - cron: '35 */8 * * *'  # 每8小时自动运行一次
  workflow_dispatch:        # 支持手动触发

concurrency:
  group: ${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  actions: write

jobs:
  update-nodes:
    runs-on: ubuntu-latest
    env:
      TZ: Asia/Shanghai  # 使用北京时间

    steps:
    - name: Checkout current repository
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
    
    - name: Record Start Time
      id: start_time
      run: |
        echo "START_TIME=$(date +'%Y-%m-%d %H:%M:%S')" >> $GITHUB_ENV
        echo "::debug::Start Time Recorded: ${{ env.START_TIME }}"

    - name: Fetch and Clean Webpage Content
      run: |
        VMESS_URL="${{ secrets.VMESS_URL }}"
        SS_URL="${{ secrets.SS_URL }}"
        
        echo "::debug::Fetching VMESS content from: $VMESS_URL" >&2
        curl -s "$VMESS_URL" | sed 's/<[^>]*>//g' > webpage_content.txt
        
        echo "::debug::Fetching SS content from: $SS_URL" >&2
        curl -s "$SS_URL" | sed 's/<[^>]*>//g' > ss_webpage_content.txt

    - name: Fetch and Update Nodes from Content Files
      run: |
        VMESS_NODES=$(grep -oP '.*vmess://\S+' webpage_content.txt | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/&amp;/\&/g' | sort -u)
        VLESS_NODES=$(grep -oP '.*vless://\S+' webpage_content.txt | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/&amp;/\&/g' | sort -u)
        SS_NODES=$(grep -oP '.*(ss://|ssr://)\S+' ss_webpage_content.txt | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/&amp;/\&/g' | sort -u)
        
        echo "$VMESS_NODES" > dizhi1.txt
        echo "$VLESS_NODES" > dizhi2.txt
        echo "$SS_NODES" > dizhi3.txt

    - name: Checkout target repository
      uses: actions/checkout@v4
      with:
        repository: ${{ secrets.TARGET_REPO }}
        token: ${{ secrets.TARGET_PAT }}
        path: target-repo
        fetch-depth: 0

    - name: Retrieve existing timestamp
      run: |
        if [ -f "target-repo/${{ secrets.TARGET_FOLDER }}/timestamp.txt" ]; then
          cp "target-repo/${{ secrets.TARGET_FOLDER }}/timestamp.txt" ./ || true
          echo "::debug::Copied existing timestamp file"
        else
          echo "::debug::No existing timestamp file found"
        fi

    - name: Update timestamp file
      run: |
        CURRENT_TIME=$(date +'%Y-%m-%d %H:%M:%S')
        declare -A timestamps
        
        # 从Git历史获取每个文件的最后提交时间
        get_file_commit_time() {
          local file="$1"
          # 从Git历史获取文件最后提交时间
          cd "target-repo/${{ secrets.TARGET_FOLDER }}"
          GIT_TIMESTAMP=$(git log -1 --format="%ci" -- "$file" 2>/dev/null | head -1 | cut -d' ' -f1,2 | sed 's/T/ /')
          cd - > /dev/null
          
          if [ -n "$GIT_TIMESTAMP" ] && [ "$GIT_TIMESTAMP" != "" ]; then
            echo "$GIT_TIMESTAMP"
          else
            echo ""
          fi
        }

        # 检查文件是否有变化
        check_diff() {
          local file="$1"
          local target_file="target-repo/${{ secrets.TARGET_FOLDER }}/$file"
          
          # 检查当前文件是否有实际内容（非空且非只有空白字符）
          if [ ! -s "$file" ] || ! grep -q '[^[:space:]]' "$file"; then
            echo "::debug::Current file $file is empty or has no meaningful content, skipping timestamp update"
            return 1
          fi
          
          # 如果目标文件不存在，说明是第一次创建有内容的文件，需要更新时间戳
          if [ ! -f "$target_file" ]; then
            echo "::debug::Target file $target_file does not exist, first time creation with content"
            return 0
          fi
          
          # 如果目标文件是空的，而当前文件有内容，需要更新时间戳
          if [ ! -s "$target_file" ] || ! grep -q '[^[:space:]]' "$target_file"; then
            echo "::debug::Target file $target_file is empty but current file has content, updating timestamp"
            return 0
          fi
          
          # 如果文件内容不同，则需要更新时间戳
          if ! diff -q "$file" "$target_file" >/dev/null; then
            echo "::debug::File $file has changed, updating timestamp"
            return 0
          fi
          
          # 文件内容相同，不需要更新时间戳
          return 1
        }

        # 为每个文件获取Git历史提交时间
        for i in 1 2 3; do
          file="dizhi${i}.txt"
          target_file="target-repo/${{ secrets.TARGET_FOLDER }}/$file"
          
          # 检查当前文件是否有内容
          if [ -s "$file" ] && grep -q '[^[:space:]]' "$file"; then
            if check_diff "$file"; then
              # 文件有变化，使用当前时间
              timestamps["$file"]="$CURRENT_TIME"
              echo "::debug::Updated timestamp for $file to $CURRENT_TIME (content changed)"
            else
              # 文件无变化，从Git历史获取最后提交时间
              GIT_TIME=$(get_file_commit_time "$file")
              if [ -n "$GIT_TIME" ]; then
                timestamps["$file"]="$GIT_TIME"
                echo "::debug::Using git commit time for $file: $GIT_TIME (no content change)"
              else
                # 如果Git历史中没有记录，保留原有时间戳或使用当前时间
                timestamps["$file"]="$CURRENT_TIME"
                echo "::debug::No git history for $file, using current time: $CURRENT_TIME"
              fi
            fi
          else
            echo "::debug::File $file has no content, skipping timestamp"
          fi
        done

        # 生成新的时间戳文件
        printf "dizhi1.txt:%s\n" "${timestamps[dizhi1.txt]:-}" > timestamp.txt
        printf "dizhi2.txt:%s\n" "${timestamps[dizhi2.txt]:-}" >> timestamp.txt
        printf "dizhi3.txt:%s\n" "${timestamps[dizhi3.txt]:-}" >> timestamp.txt
        
        echo "::debug::Final timestamps: dizhi1=${timestamps[dizhi1.txt]:-}, dizhi2=${timestamps[dizhi2.txt]:-}, dizhi3=${timestamps[dizhi3.txt]:-}"

    - name: Copy files to target repository
      run: |
        cp -v dizhi*.txt ss_webpage_content.txt webpage_content.txt timestamp.txt "target-repo/${{ secrets.TARGET_FOLDER }}/"
        # 如果存在myIP.txt，也复制到目标目录
        if [ -f "target-repo/${{ secrets.TARGET_FOLDER }}/myIP.txt" ]; then
          cp -v "target-repo/${{ secrets.TARGET_FOLDER }}/myIP.txt" ./
        fi

    - name: Process myDizhi.txt with IP/Port Replacement (FIXED IPv6)
      run: |
        # 1. 定义路径和检查文件
        TARGET_FOLDER="${{ secrets.TARGET_FOLDER }}"
        TARGET_MYDIZHI="target-repo/${TARGET_FOLDER}/myDizhi.txt"
        TARGET_MYIP="target-repo/${TARGET_FOLDER}/myIP.txt"
        OUTPUT_FILE="myDizhi_modified.txt"

        if [ ! -f "$TARGET_MYDIZHI" ]; then
          echo "::error::myDizhi.txt not found at $TARGET_MYDIZHI, skipping."
          exit 0
        fi

        if [ ! -f "$TARGET_MYIP" ]; then
          echo "::error::myIP.txt not found, skipping replacement. File copied directly to output."
          cp "$TARGET_MYDIZHI" "$OUTPUT_FILE"
          exit 0
        fi

        # 2. 提取 IP/域名 池
        # 逻辑：匹配 @ 之后，直到遇到 ?、# 或行尾之前的非空字符。
        mapfile -t NORMAL_IP_POOL < <(grep -v "gemini" "$TARGET_MYIP" | grep -oP '@\K[^?#\s]+' | grep ':')
        mapfile -t GEMINI_IP_POOL < <(grep "gemini" "$TARGET_MYIP" | grep -oP '@\K[^?#\s]+' | grep ':')

        NORMAL_POOL_SIZE=${#NORMAL_IP_POOL[@]}
        GEMINI_POOL_SIZE=${#GEMINI_IP_POOL[@]}

        echo "::debug::IP Pool Check: Found $NORMAL_POOL_SIZE normal Addrs and $GEMINI_POOL_SIZE gemini Addrs."

        if [ "$NORMAL_POOL_SIZE" -eq 0 ]; then
          echo "::error::No valid addresses found in myIP.txt, keeping original."
          cp "$TARGET_MYDIZHI" "$OUTPUT_FILE"
          exit 0
        fi

        # 3. 初始化
        NORMAL_COUNTER=0
        GEMINI_COUNTER=0
        > "$OUTPUT_FILE"

        # 提取待处理节点
        grep -E '^(vless|vmess|trojan)://' "$TARGET_MYDIZHI" > /tmp/nodes.txt

        echo "::debug::Starting node processing loop..."

        # 4. 处理每个节点
        while IFS= read -r line; do
          LINE_NUM=$((LINE_NUM+1))

          # 清理首尾空白和 Windows 换行符
          line=$(echo "$line" | tr -d '\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

          echo "::debug::--- Line $LINE_NUM: Start ---"
          
          # --- VMess 节点处理 ---
          if [[ "$line" =~ ^vmess:// ]]; then
            BASE64_STR=${line#vmess://}
            # 修复 Base64 解码可能的填充问题
            CLEAN_BASE64_STR=$(echo "$BASE64_STR" | tr -d '\r\n\t ' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            JSON_STR=$(echo "$CLEAN_BASE64_STR" | base64 -d 2>/dev/null || echo "")

            if [ -z "$JSON_STR" ]; then
              echo "::error::Line $LINE_NUM: VMess BASE64 decode failed."
              echo "$line" >> "$OUTPUT_FILE"
              continue
            fi

            if echo "$JSON_STR" | jq empty 2>/dev/null; then
              # --- 地址替换逻辑 ---
              # 判断使用哪个池
              if echo "$JSON_STR" | grep -q "gemini"; then
                # 使用 Gemini 池
                if [ "$GEMINI_POOL_SIZE" -gt 0 ]; then
                  POOL_ARRAY=("${GEMINI_IP_POOL[@]}")
                  IDX=$((GEMINI_COUNTER % GEMINI_POOL_SIZE))
                  GEMINI_COUNTER=$((GEMINI_COUNTER + 1))
                  USE_POOL="Gemini"
                else
                  # 回退或跳过
                  echo "$line" >> "$OUTPUT_FILE"
                  continue
                fi
              else
                # 使用普通池
                POOL_ARRAY=("${NORMAL_IP_POOL[@]}")
                IDX=$((NORMAL_COUNTER % NORMAL_POOL_SIZE))
                NORMAL_COUNTER=$((NORMAL_COUNTER + 1))
                USE_POOL="Normal"
              fi

              # [关键修复] 获取新地址并正确分离端口
              CURRENT_PAIR="${POOL_ARRAY[$IDX]}"
              
              # 使用 ##*: 匹配最后一个冒号，确保 IPv6 [::1]:443 能正确提取 443
              NEW_PORT=${CURRENT_PAIR##*:}
              # 使用 %:* 删除最后一个冒号及其后的内容
              NEW_IP=${CURRENT_PAIR%:*}
              
              # [关键修复] VMess JSON 的 add 字段通常不需要方括号
              # 如果 NEW_IP 包含 []，则去掉，用于 JSON
              JSON_IP=$(echo "$NEW_IP" | tr -d '[]')

              NEW_JSON=$(echo "$JSON_STR" | jq -c --arg ip "$JSON_IP" --arg port "$NEW_PORT" '.add = $ip | .port = $port')
              NEW_BASE64=$(echo -n "$NEW_JSON" | base64 -w 0)
              echo "vmess://$NEW_BASE64" >> "$OUTPUT_FILE"
              echo "::debug::Line $LINE_NUM: **$USE_POOL VMess Updated** -> Addr: $NEW_IP, Port: $NEW_PORT"

            else
              echo "::error::Line $LINE_NUM: VMess JSON parse failed."
              echo "$line" >> "$OUTPUT_FILE"
            fi

          # --- VLESS / Trojan 处理 ---
          elif [[ "$line" =~ ^(vless|trojan):// ]]; then
            PROTOCOL="${BASH_REMATCH[1]}"
            
            # 确定使用哪个池
            USE_POOL=""
            if echo "$line" | grep -q "gemini"; then
              if [ "$GEMINI_POOL_SIZE" -gt 0 ]; then
                  POOL_ARRAY=("${GEMINI_IP_POOL[@]}")
                  IDX=$((GEMINI_COUNTER % GEMINI_POOL_SIZE))
                  GEMINI_COUNTER=$((GEMINI_COUNTER + 1))
                  USE_POOL="Gemini"
              fi
            else
              POOL_ARRAY=("${NORMAL_IP_POOL[@]}")
              IDX=$((NORMAL_COUNTER % NORMAL_POOL_SIZE))
              NORMAL_COUNTER=$((NORMAL_COUNTER + 1))
              USE_POOL="Normal"
            fi

            # [关键修复] 增强正则以支持 IPv6 作为目标节点
            # 旧正则: ([^:]+) 会在 IPv6 的冒号处断开
            # 新正则: 匹配 @ 之后，直到遇到 / ? # 之前的字符串作为 HOST:PORT 块
            if [ -n "$USE_POOL" ] && [[ "$line" =~ ^([a-z]+)://([^@]+)@([^/?#]+)(.*)$ ]]; then
              USER_INFO="${BASH_REMATCH[2]}"
              OLD_ADDR_BLOCK="${BASH_REMATCH[3]}"
              REST_PARAMS="${BASH_REMATCH[4]}"
              
              # 获取新地址
              CURRENT_PAIR="${POOL_ARRAY[$IDX]}"
              NEW_IP=${CURRENT_PAIR%:*}     # 这里保留方括号，如 [::1]
              NEW_PORT=${CURRENT_PAIR##*:}  # 这里使用 ## 修复端口提取

              # 拼接新链接 (VLESS URI 必须保留 IPv6 的方括号)
              echo "${PROTOCOL}://${USER_INFO}@${NEW_IP}:${NEW_PORT}${REST_PARAMS}" >> "$OUTPUT_FILE"
              echo "::debug::Line $LINE_NUM: **$USE_POOL ${PROTOCOL} Updated** -> Addr: $NEW_IP, Port: $NEW_PORT"
            else
              echo "::debug::Line $LINE_NUM: Skipping ${PROTOCOL} (No IP pool or Regex mismatch)"
              echo "$line" >> "$OUTPUT_FILE"
            fi

          else
            echo "::debug::Line $LINE_NUM: Not a node line, keeping original."
            echo "$line" >> "$OUTPUT_FILE"
          fi
          echo "::debug::--- Line $LINE_NUM: End ---"

        done < /tmp/nodes.txt

        # 5. 添加非节点内容和保存
        grep -vE '^(vless|vmess|trojan)://' "$TARGET_MYDIZHI" >> "$OUTPUT_FILE"
        mkdir -p "target-repo/${TARGET_FOLDER}"
        cp "$OUTPUT_FILE" "target-repo/${TARGET_FOLDER}/myDizhi_modified.txt"
        echo "::debug::Success! Processed myDizhi.txt with Domain/IP replacement (IPv6 Fixed)"

    - name: Generate Report (Independent)
      run: |
        set -euo pipefail
        
        # 使用之前记录的开始时间
        START_TIME="${{ env.START_TIME }}"
        END_TIME=$(date +'%Y-%m-%d %H:%M:%S')
        START_SEC=$(date -d "$START_TIME" +%s)
        END_SEC=$(date -d "$END_TIME" +%s)
        DURATION=$((END_SEC - START_SEC))
        FORMATTED_DURATION=$(printf "%02d:%02d:%02d" $((DURATION/3600)) $((DURATION%3600/60)) $((DURATION%60)))
        
        # 计算时间差
        CURRENT_SEC=$(date +%s)
        
        # 设置默认值
        D1_DAYS=0
        D2_DAYS=0
        D3_DAYS=0
        
        # 读取时间戳文件
        if [ -f "timestamp.txt" ]; then
          # 定义函数计算时间差
          get_days_diff() {
            local file_date="$1"
            # 检查日期是否为空或无效
            if [ -z "$file_date" ]; then
              echo "0"
              return
            fi
            # 尝试解析日期，如果失败则返回0
            local file_sec
            file_sec=$(date -d "$file_date" +%s 2>/dev/null) || file_sec=0
            # 使用awk计算差值，避免依赖bc
            local days_diff
            days_diff=$(awk "BEGIN {printf \"%.1f\", ($CURRENT_SEC - $file_sec)/86400}")
            echo "$days_diff"
          }
          
          # 逐行读取时间戳文件并处理
          while IFS=: read -r key value; do
            # 去除key和value的前后空格
            key=$(echo "$key" | xargs)  # xargs会去除前后空格
            value=$(echo "$value" | xargs)
            
            case "$key" in
              "dizhi1.txt")
                D1_DAYS=$(get_days_diff "$value")
                ;;
              "dizhi2.txt")
                D2_DAYS=$(get_days_diff "$value")
                ;;
              "dizhi3.txt")
                D3_DAYS=$(get_days_diff "$value")
                ;;
            esac
          done < "timestamp.txt"
        fi

        # 生成报告节点
        {
          echo "trojan://CMLiussss@127.0.0.1:8888?security=tls&allowInsecure=1&type=tcp&headerType=none#%23报告A $START_TIME 耗时: $FORMATTED_DURATION"
          echo "trojan://CMLiussss@127.0.0.1:8888?security=tls&allowInsecure=1&type=tcp&headerType=none#%23报告A vm:${D1_DAYS} vl:${D2_DAYS} ss:${D3_DAYS}"
        } > "dizhiR.txt"
        
        # 复制报告节点到目标仓库
        mkdir -p "target-repo/${{ secrets.TARGET_FOLDER }}"
        cp "dizhiR.txt" "target-repo/${{ secrets.TARGET_FOLDER }}/"
        
        echo "::notice::Independent report generated with start time: $START_TIME, end time: $END_TIME, duration: $FORMATTED_DURATION"

    - name: Generate dizhi123.txt
      run: |
        TARGET_DIR="target-repo/${{ secrets.TARGET_FOLDER }}"
        
        # 生成dizhi123.txt文件（与3→4→5链式流程生成相同文件）
        {
          # 合并原有节点文件（每个文件只输出一次）
          cat "$TARGET_DIR/dizhi1.txt" 2>/dev/null || true
          echo
          cat "$TARGET_DIR/dizhi2.txt" 2>/dev/null || true
          echo
          cat "$TARGET_DIR/dizhi3.txt" 2>/dev/null || true
          echo
          
          # 添加处理后的 myDizhi 节点（包含 IP 替换）
          if [ -f "$TARGET_DIR/myDizhi_modified.txt" ]; then
            grep -E '^(vless|vmess|trojan)://' "$TARGET_DIR/myDizhi_modified.txt" || true
            echo
          fi
          
          # 添加报告节点
          cat "$TARGET_DIR/dizhiR.txt"
          echo
          
          # 添加原始myDizhi.txt中的所有节点（包括gemini节点）
          if [ -f "$TARGET_DIR/myDizhi.txt" ]; then
            echo "::debug::Processing updated myDizhi.txt"
            
            # 添加所有节点，包括gemini节点，不进行过滤
            grep -E '^(vless|vmess|trojan|ss|ssr)://' "$TARGET_DIR/myDizhi.txt" || true
            echo "::debug::Extracted all nodes from modified myDizhi.txt (including gemini nodes)"
          fi
        } > "$TARGET_DIR/dizhi123.txt"
        
        echo "::notice::dizhi123.txt generated successfully (independent of workflows 4 and 5)"

    - name: Commit and Push changes
      run: |
        cd target-repo
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "github-actions-bot@users.noreply.github.com"
        
        git add .
        COMMIT_MESSAGE="Auto-update at ${{ env.START_TIME }}: Node data collection and report generated"
        if git commit -m "$COMMIT_MESSAGE"; then
          git push origin main
        else
          echo "::debug::No changes to commit"
        fi

    - name: Delete workflow runs
      uses: Mattraks/delete-workflow-runs@v2
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        repository: ${{ github.repository }}
        retain_days: 0
        keep_minimum_runs: 2