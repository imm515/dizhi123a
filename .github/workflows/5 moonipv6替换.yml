name: 5 IPv6 Node Processor and Aggregation

on:
  workflow_dispatch:
    inputs:
      vless_count:
        description: 'Number of IPv6 VLESS nodes to generate per group (Should be 6).'
        required: false
        default: '6'
        type: string
  workflow_run:
    workflows: ["4 Selenium IPv6聚合与时间记录"]
    types:
      - completed 

concurrency:
  group: ${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  actions: write

jobs:
  process_ipv6_nodes:
    runs-on: ubuntu-latest
    env:
      TZ: Asia/Shanghai
      # 沿用 3.yml 的 secrets 配置
      TARGET_FOLDER: ${{ secrets.TARGET_FOLDER }}
      # 目标生成数量（每组），默认为 6
      VLESS_COUNT: ${{ github.event.inputs.vless_count || '6' }}

    steps:
      - name: Checkout current repository
        uses: actions/checkout@v4

      - name: Install dependencies (jq and python, perl is available by default)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq python3 python3-pip
          pip3 install urllib3

      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.TARGET_REPO }}
          token: ${{ secrets.TARGET_PAT }}
          path: target-repo
          fetch-depth: 0

      - name: Process IPv6 Replacement and Generate Nodes (myDizhi_ipv6_modified.txt)
        id: node_gen
        run: |
          set -euo pipefail

          # 定义文件路径（把输出文件直接写到目标仓库目录，便于后续合并与提交）
          TARGET_DIR="target-repo/${{ env.TARGET_FOLDER }}"
          MYDIZHI_FILE="${TARGET_DIR}/myDizhi.txt"
          MYIPV6_FILE="${TARGET_DIR}/myIPv6.txt"
          OUTPUT_MOD_FILE="${TARGET_DIR}/myDizhi_ipv6_modified.txt"

          # 检查源文件是否存在
          if [ ! -f "$MYDIZHI_FILE" ]; then
            echo "::error::myDizhi.txt not found at $MYDIZHI_FILE. Exiting."
            exit 1
          fi
          if [ ! -f "$MYIPV6_FILE" ]; then
            echo "::error::myIPv6.txt not found at $MYIPV6_FILE. Exiting."
            exit 1
          fi

          # 提取第一个 VLESS 节点作为模板（排除注释行）
          VLESS_TEMPLATE=$(grep -m 1 '^vless://' "$MYDIZHI_FILE" || true) 
          if [ -z "$VLESS_TEMPLATE" ]; then
            echo "::error::No VLESS node found in myDizhi.txt. Exiting."
            exit 1
          fi
          echo "::debug::VLESS Template found: $VLESS_TEMPLATE"

          # 导出变量，确保 Python 子进程能通过 os.environ 读到
          export VLESS_TEMPLATE
          export MYIPV6_FILE
          export OUTPUT_MOD_FILE
          export VLESS_COUNT="${{ env.VLESS_COUNT }}"

          # 运行 Python 生成文件（Python 中会写入 $OUTPUT_MOD_FILE）
          python3 - <<'PY'
          import os, re
          from urllib.parse import urlparse, parse_qs, urlencode, unquote

          # 从导出的环境变量中获取值
          VLESS_TEMPLATE = os.environ['VLESS_TEMPLATE']
          MYIPV6_FILE = os.environ['MYIPV6_FILE']
          OUTPUT_MOD_FILE = os.environ['OUTPUT_MOD_FILE']
          # VLESS_COUNT 现在代表每个分组需要生成的节点数量
          VLESS_COUNT = int(os.environ.get('VLESS_COUNT', '6')) 

          # 端口列表，用于生成 6 个节点
          PORTS = [443, 2053, 2083, 2087, 2096, 8443]

          # 解析 VLESS 模板
          def parse_vless(url):
              try:
                  match = re.match(r'vless://([^@]+)@([^:]+):(\d+)([^#]*)#?(.*)', url)
                  if match:
                      uuid = match.group(1)
                      name = match.group(5) or "" # 确保 name 至少是空字符串
                      
                      # 使用 temp_url 确保 urlparse 能正确处理 query 部分
                      temp_url = url.replace(f"vless://{uuid}@", "https://", 1)
                      parsed_url = urlparse(temp_url)
                      
                      # 解析参数
                      query_params = parse_qs(parsed_url.query)
                      # urlencode 将参数转换为 key=value&key2=value2 格式
                      clean_params = urlencode(query_params, doseq=True)
                      
                      return {'uuid': uuid, 'clean_params': clean_params, 'name': name}
              except Exception as e:
                  print(f"::error::parse_vless error: {e}")
              return None

          # 读取 IPv6 地址池，并按 Source 分组返回
          def get_ipv6_groups(file_path):
              """读取文件并返回分组的 IPv6 地址列表，格式为 [{'source': name, 'ips': [ip1, ip2, ...]}, ...]"""
              all_groups = []
              current_group_ips = []
              # 默认名称，用于处理文件开头可能存在的 IP (尽管在您的格式中不太可能)
              current_source_name = "UNGROUPED_IPV6" 
              # 匹配分组头，并捕获 Source 名称
              group_start_pattern = re.compile(r'^# === Source: ([^ ]+).*?===')

              try:
                  with open(file_path, 'r', encoding='utf-8') as f:
                      for line in f:
                          line = line.strip()
                          if not line:
                              continue

                          # 1. 检查分组开始标记
                          match_group = group_start_pattern.match(line)
                          if match_group:
                              # 保存前一个分组 (如果有 IP)
                              if current_group_ips:
                                  all_groups.append({'source': current_source_name, 'ips': current_group_ips})
                              
                              # 开始新分组
                              current_source_name = match_group.group(1).strip()
                              current_group_ips = []
                              continue

                          # 2. 检查 IP 数据行 (需要包含 IPv6 地址和 |)
                          # 匹配 IPv6 地址，可能是缩写或完整形式，且后面有 |
                          if re.match(r'^(?:[0-9a-fA-F:]+|\[[0-9a-fA-F:]+\])\s*\|', line):
                              parts = line.split('|')
                              ip = parts[0].strip().strip('[]') # 剥离 IP 和可能的方括号
                              
                              if ':' in ip:
                                  current_group_ips.append(ip)

                  # 3. 添加最后一个分组
                  if current_group_ips:
                      all_groups.append({'source': current_source_name, 'ips': current_group_ips})
                      
              except Exception as e:
                  print(f"::error::get_ipv6_groups failed: {e}")
                  return []
              
              return all_groups

          # 生成新节点
          def generate_nodes(template_data, ipv6_groups, count_per_group):
              """为每个 IP 分组生成指定数量的 VLESS 节点。"""
              nodes = []
              total_generated = 0
              
              if not template_data or not ipv6_groups:
                  return nodes
                  
              # 确保生成的节点数量不超过可用端口数量
              num_to_generate = min(count_per_group, len(PORTS))
              
              for group_data in ipv6_groups:
                  ip_group = group_data['ips']
                  source = group_data['source']
                  
                  if not ip_group:
                      print(f"::warning::Skipping empty group: {source}")
                      continue

                  for i in range(num_to_generate):
                      # 循环获取 IPv6 地址，确保凑够 6 个节点
                      ip = ip_group[i % len(ip_group)]
                      port = PORTS[i]
                      
                      # 1. 解码原始节点名称
                      original_name = unquote(template_data['name'])
                      
                      # 2. 构造新的节点名称: [原名] | [Source] | [Port]
                      new_name = f"{original_name} | {source} | {port}"
                      # VLESS URI 规范要求 #Name 部分必须进行 URL 编码（这里使用 %20 替换空格，实际 URL 库已处理）
                      name_encoded = new_name.replace(' ', '%20')

                      # 3. 拼接参数和地址
                      params_suffix = f"?{template_data['clean_params']}" if template_data['clean_params'] else ""
                      ip_with_brackets = f"[{ip}]" # IPv6 地址必须用方括号包围
                      
                      new_url = (
                          f"vless://{template_data['uuid']}@{ip_with_brackets}:{port}"
                          f"{params_suffix}"
                          f"#{name_encoded}"
                      )
                      nodes.append(new_url)
                      total_generated += 1
                      
              print(f"::debug::Total nodes generated across all groups: {total_generated}")
              return nodes

          # --- Main Execution ---
          template = parse_vless(VLESS_TEMPLATE)
          ipv6_groups = get_ipv6_groups(MYIPV6_FILE)
          total_groups = len(ipv6_groups)
          
          if not ipv6_groups:
              print("::error::No IPv6 groups found or file format is incorrect. Exiting.")
              generated = []
          else:
              print(f"::notice::Found {total_groups} IPv6 groups. Generating {VLESS_COUNT} nodes per group.")
              generated = generate_nodes(template, ipv6_groups, VLESS_COUNT)

          # 写入生成的文件
          with open(OUTPUT_MOD_FILE, 'w', encoding='utf-8') as fh:
              for n in generated:
                  fh.write(n + '\n')

          # 写入总节点数 (注意，这里是总节点数，不再是每组的节点数)
          ipv6_total_count = len(generated)
          print(f"::notice::Generated {ipv6_total_count} total nodes into {OUTPUT_MOD_FILE}")

          # 向 GITHUB_OUTPUT 输出两个参数，供后续 step 使用 steps.node_gen.outputs.*
          gout = os.environ.get('GITHUB_OUTPUT')
          if gout:
              with open(gout, 'a') as gf:
                  # 输出总节点数，用于 Commit Message
                  gf.write(f"ipv6_count={ipv6_total_count}\n") 
                  gf.write(f"modified_file_path={OUTPUT_MOD_FILE}\n")
          PY

      - name: Update dizhi123.txt with New IPv6 Nodes
        # 即使总节点数为 0 (0 * N=0)，也需要运行以清理旧的 IPv6 块
        # if: steps.node_gen.outputs.ipv6_count != '0' # 移除这个限制
        run: |
          set -euo pipefail

          # 从 GITHUB_OUTPUT 获取路径和数量，确保使用正确的目录
          DIZHI123_FILE="target-repo/${{ env.TARGET_FOLDER }}/dizhi123.txt"
          MOD_FILE="${{ steps.node_gen.outputs.modified_file_path }}"
          # 注意：这里的 IPV6_COUNT 是生成的总节点数
          IPV6_COUNT="${{ steps.node_gen.outputs.ipv6_count }}"

          # 确保 MOD_FILE 存在 (它应该在 target-repo 目录内)
          if [ -z "$MOD_FILE" ] || [ ! -f "$MOD_FILE" ]; then
            echo "::error::Modified file not found: $MOD_FILE"
            # 即使文件不存在，清理操作仍应尝试运行，但这里可以跳过生成新块
          fi

          # 确保 dizhi123 存在，如果不存在则创建
          if [ ! -f "$DIZHI123_FILE" ]; then
            echo "::warning::dizhi123.txt not found, creating new one at $DIZHI123_FILE"
            mkdir -p "$(dirname "$DIZHI123_FILE")"
            touch "$DIZHI123_FILE"
          fi

          CURRENT_TIME=$(date +'%Y-%m-%d %H:%M:%S')
          START_MARKER="--- 新增${IPV6_COUNT}个分组端口IPv6总节点 (GMT+8: ${CURRENT_TIME}) ---"
          END_MARKER="------------------------------------------------------------------" # 加长分隔线以提高唯一性

          # 使用 perl 进行稳健的块删除操作
          # 匹配范围：从 "--- 新增" 开始，到 "--------------------------------------------------" 结束
          perl -0777 -pe 's/--- 新增.*?个分组端口IPv6总节点.*?------------------------------------------------------------------\n?//s' "$DIZHI123_FILE" > /tmp/dizhi123_stripped.txt || true
          
          # 如果有新节点生成，则生成新块并合并
          if [ "$IPV6_COUNT" -gt 0 ]; then
            # 生成新块到临时文件
            {
              echo "$START_MARKER"
              cat "$MOD_FILE"
              echo "$END_MARKER"
            } > /tmp/new_ipv6_block.txt
            
            # 现在把新块和被清理后的内容合并为最终文件 (新块始终在顶部)
            cat /tmp/new_ipv6_block.txt /tmp/dizhi123_stripped.txt > /tmp/dizhi123_new.txt
            mv /tmp/dizhi123_new.txt "$DIZHI123_FILE"
            echo "::notice::dizhi123.txt updated (prepended new IPv6 block with $IPV6_COUNT nodes)."
          else
            # 如果没有生成节点，仅保留清理后的 dizhi123.txt
            mv /tmp/dizhi123_stripped.txt "$DIZHI123_FILE"
            echo "::notice::No IPv6 nodes generated. Old IPv6 block was successfully removed."
          fi

      - name: Record End Time and Generate Report
        run: |
          set -euo pipefail
          
          # 从工作流2保存的文件中读取开始时间
          if [ -f "target-repo/${{ env.TARGET_FOLDER }}/workflow_start_time.txt" ]; then
            START_TIME=$(cat "target-repo/${{ env.TARGET_FOLDER }}/workflow_start_time.txt")
          else
            # 如果文件不存在，使用当前时间作为开始时间
            START_TIME=$(date +'%Y-%m-%d %H:%M:%S')
          fi
          
          # 记录结束时间并计算持续时间
          END_TIME=$(date +'%Y-%m-%d %H:%M:%S')
          START_SEC=$(date -d "$START_TIME" +%s)
          END_SEC=$(date -d "$END_TIME" +%s)
          DURATION=$((END_SEC - START_SEC))
          FORMATTED_DURATION=$(printf "%02d:%02d:%02d" $((DURATION/3600)) $((DURATION%3600/60)) $((DURATION%60)))
          
          # 计算时间差
          CURRENT_SEC=$(date +%s)
          
          # 设置默认值
          D1_DAYS=0
          D2_DAYS=0
          D3_DAYS=0
          
          # 读取时间戳文件
          if [ -f "target-repo/${{ env.TARGET_FOLDER }}/timestamp.txt" ]; then
            # 定义函数计算时间差
            get_days_diff() {
              local file_date="$1"
              # 检查日期是否为空或无效
              if [ -z "$file_date" ]; then
                echo "0"
                return
              fi
              # 尝试解析日期，如果失败则返回0
              local file_sec
              file_sec=$(date -d "$file_date" +%s 2>/dev/null) || file_sec=0
              # 使用awk计算差值，避免依赖bc
              local days_diff
              days_diff=$(awk "BEGIN {printf \"%.1f\", ($CURRENT_SEC - $file_sec)/86400}")
              echo "$days_diff"
            }
            
            # 逐行读取时间戳文件并处理
            while IFS=: read -r key value; do
              # 去除key和value的前后空格
              key=$(echo "$key" | xargs)  # xargs会去除前后空格
              value=$(echo "$value" | xargs)
              
              case "$key" in
                "dizhi1.txt")
                  D1_DAYS=$(get_days_diff "$value")
                  ;;
                "dizhi2.txt")
                  D2_DAYS=$(get_days_diff "$value")
                  ;;
                "dizhi3.txt")
                  D3_DAYS=$(get_days_diff "$value")
                  ;;
              esac
            done < "target-repo/${{ env.TARGET_FOLDER }}/timestamp.txt"
          fi

          # 生成报告节点
          {
            echo "trojan://CMLiussss@127.0.0.1:8888?security=tls&allowInsecure=1&type=tcp&headerType=none#%23报告A $START_TIME 耗时: $FORMATTED_DURATION"
            echo "trojan://CMLiussss@127.0.0.1:8888?security=tls&allowInsecure=1&type=tcp&headerType=none#%23报告A vm:${D1_DAYS} vl:${D2_DAYS} ss:${D3_DAYS}"
          } > "target-repo/${{ env.TARGET_FOLDER }}/dizhiR.txt"
          
          echo "::notice::Report generated with start time: $START_TIME, end time: $END_TIME, duration: $FORMATTED_DURATION"

      - name: Generate Final dizhi123.txt
        run: |
          set -euo pipefail
          
          TARGET_DIR="target-repo/${{ env.TARGET_FOLDER }}"
          
          # 生成最终的dizhi123.txt文件
          {
            # 合并原有节点文件（每个文件只输出一次）
            cat "$TARGET_DIR/dizhi1.txt" 2>/dev/null || true
            echo
            cat "$TARGET_DIR/dizhi2.txt" 2>/dev/null || true
            echo
            cat "$TARGET_DIR/dizhi3.txt" 2>/dev/null || true
            echo
            
            # 添加处理后的 myDizhi 节点（包含 IP 替换）
            if [ -f "$TARGET_DIR/myDizhi_modified.txt" ]; then
              grep -E '^(vless|vmess|trojan)://' "$TARGET_DIR/myDizhi_modified.txt" || true
              echo
            fi
            
            # 添加IPv6节点（如果存在）
            IPV6_COUNT="${{ steps.node_gen.outputs.ipv6_count }}"
            if [ "$IPV6_COUNT" -gt 0 ] && [ -f "$TARGET_DIR/myDizhi_ipv6_modified.txt" ]; then
              echo "--- 新增${IPV6_COUNT}个分组端口IPv6总节点 (GMT+8: $(date +'%Y-%m-%d %H:%M:%S')) ---"
              cat "$TARGET_DIR/myDizhi_ipv6_modified.txt"
              echo "------------------------------------------------------------------"
              echo
            fi
            
            # 添加报告节点
            cat "$TARGET_DIR/dizhiR.txt"
            echo
            
            # 添加原始myDizhi.txt中的所有节点（包括gemini节点）
            if [ -f "$TARGET_DIR/myDizhi.txt" ]; then
              echo "::debug::Processing updated myDizhi.txt"
              
              # 添加所有节点，包括gemini节点，不进行过滤
              grep -E '^(vless|vmess|trojan|ss|ssr)://' "$TARGET_DIR/myDizhi.txt" || true
              echo "::debug::Extracted all nodes from modified myDizhi.txt (including gemini nodes)"
            fi
          } > "$TARGET_DIR/dizhi123.txt"
          
          echo "::notice::Final dizhi123.txt generated successfully"

      - name: Commit and Push all changes
        run: |
          set -euo pipefail

          cd target-repo
          
          git config user.name "GitHub Actions Bot"
          git config user.email "github-actions-bot@users.noreply.github.com"
          
          # 添加所有修改的文件
          git add "${{ env.TARGET_FOLDER }}/" || true
          
          if ! git diff --cached --quiet --exit-code; then
              echo "Committing all changes..."
              # 提交信息使用总节点数和时间信息
              START_TIME=$(cat "${{ env.TARGET_FOLDER }}/workflow_start_time.txt" 2>/dev/null || echo "$(date +'%Y-%m-%d %H:%M:%S')")
              IPV6_COUNT="${{ steps.node_gen.outputs.ipv6_count }}"
              git commit -m "Auto-update at $(date +'%Y-%m-%d %H:%M:%S'): Generated $IPV6_COUNT IPv6 nodes and final report"
              git push
              echo "::notice::Successfully committed and pushed all changes."
          else
              echo "No changes detected. Skipping commit."
          fi