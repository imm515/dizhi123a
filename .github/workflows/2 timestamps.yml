name: 2 Time

on:
  schedule:
    - cron: '35 */8 * * *'  # 每8小时自动运行一次
  workflow_dispatch:        # 支持手动触发

concurrency:
  group: ${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  actions: write

jobs:
  update-nodes:
    runs-on: ubuntu-latest
    env:
      TZ: Asia/Shanghai  # 使用北京时间

    steps:
    - name: Checkout current repository
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
    
    - name: Record Start Time
      id: start_time
      run: |
        echo "START_TIME=$(date +'%Y-%m-%d %H:%M:%S')" >> $GITHUB_ENV
        echo "::debug::Start Time Recorded: ${{ env.START_TIME }}"

    - name: Fetch and Clean Webpage Content
      run: |
        VMESS_URL="${{ secrets.VMESS_URL }}"
        SS_URL="${{ secrets.SS_URL }}"
        
        echo "::debug::Fetching VMESS content from: $VMESS_URL" >&2
        curl -s "$VMESS_URL" | sed 's/<[^>]*>//g' > webpage_content.txt
        
        echo "::debug::Fetching SS content from: $SS_URL" >&2
        curl -s "$SS_URL" | sed 's/<[^>]*>//g' > ss_webpage_content.txt

    - name: Fetch and Update Nodes from Content Files
      run: |
        VMESS_NODES=$(grep -oP '.*vmess://\S+' webpage_content.txt | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/&amp;/\&/g' | sort -u)
        VLESS_NODES=$(grep -oP '.*vless://\S+' webpage_content.txt | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/&amp;/\&/g' | sort -u)
        SS_NODES=$(grep -oP '.*(ss://|ssr://)\S+' ss_webpage_content.txt | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/&amp;/\&/g' | sort -u)
        
        echo "$VMESS_NODES" > dizhi1.txt
        echo "$VLESS_NODES" > dizhi2.txt
        echo "$SS_NODES" > dizhi3.txt

    - name: Checkout target repository
      uses: actions/checkout@v4
      with:
        repository: ${{ secrets.TARGET_REPO }}
        token: ${{ secrets.TARGET_PAT }}
        path: target-repo
        fetch-depth: 0

    - name: Retrieve existing timestamp
      run: |
        if [ -f "target-repo/${{ secrets.TARGET_FOLDER }}/timestamp.txt" ]; then
          cp "target-repo/${{ secrets.TARGET_FOLDER }}/timestamp.txt" ./ || true
          echo "::debug::Copied existing timestamp file"
        else
          echo "::debug::No existing timestamp file found"
        fi

    - name: Update timestamp file
      run: |
        CURRENT_TIME=$(date +'%Y-%m-%d %H:%M:%S')
        declare -A timestamps
        
        # 读取现有时间戳
        if [ -f "timestamp.txt" ]; then
          while IFS=: read -r key value; do
            timestamps["$key"]="$value"
          done < timestamp.txt
        fi

        # 检查文件是否有变化
        check_diff() {
          local file="$1"
          local target_file="target-repo/${{ secrets.TARGET_FOLDER }}/$file"
          if [ -f "$target_file" ] && ! diff -q "$file" "$target_file" >/dev/null; then
            return 0
          else
            return 1
          fi
        }

        # 更新需要变更的时间戳
        for i in 1 2 3; do
          file="dizhi${i}.txt"
          if check_diff "$file"; then
            timestamps["$file"]="$CURRENT_TIME"
            echo "::debug::Updated timestamp for $file"
          elif [ -z "${timestamps[$file]}" ]; then
            timestamps["$file"]="$CURRENT_TIME"
            echo "::debug::Initialized timestamp for $file"
          fi
        done

        # 生成新的时间戳文件
        printf "dizhi1.txt:%s
          dizhi2.txt:%s
          dizhi3.txt:%s
          " \
          "${timestamps[dizhi1.txt]}" \
          "${timestamps[dizhi2.txt]}" \
          "${timestamps[dizhi3.txt]}" > timestamp.txt

    - name: Copy files to target repository
      run: |
        cp -v dizhi*.txt ss_webpage_content.txt webpage_content.txt timestamp.txt "target-repo/${{ secrets.TARGET_FOLDER }}/"
        # 如果存在myIP.txt，也复制到目标目录
        if [ -f "target-repo/${{ secrets.TARGET_FOLDER }}/myIP.txt" ]; then
          cp -v "target-repo/${{ secrets.TARGET_FOLDER }}/myIP.txt" ./
        fi

    - name: Process myDizhi.txt with IP/Port Replacement (DEBUG VERSION)
      run: |
        # 1. 定义路径和检查文件
        TARGET_FOLDER="${{ secrets.TARGET_FOLDER }}"
        TARGET_MYDIZHI="target-repo/${TARGET_FOLDER}/myDizhi.txt"
        TARGET_MYIP="target-repo/${TARGET_FOLDER}/myIP.txt"
        OUTPUT_FILE="myDizhi_modified.txt"

        if [ ! -f "$TARGET_MYDIZHI" ]; then
          echo "::error::myDizhi.txt not found at $TARGET_MYDIZHI, skipping."
          exit 0
        fi

        if [ ! -f "$TARGET_MYIP" ]; then
          echo "::error::myIP.txt not found, skipping replacement. File copied directly to output."
          cp "$TARGET_MYDIZHI" "$OUTPUT_FILE"
          exit 0
        fi

        # [cite_start]2. 提取 IP/域名 池 (修改版：支持域名直接读取) [cite: 142-455]
        # 逻辑：匹配 @ 之后，直到遇到 ?、# 或行尾之前的非空字符。这可以同时捕获 "IP:Port" 和 "Domain:Port"
        # 并不做格式校验，视同有效地址处理。
        mapfile -t NORMAL_IP_POOL < <(grep -v "gemini" "$TARGET_MYIP" | grep -oP '@\K[^?#\s]+' | grep ':')
        mapfile -t GEMINI_IP_POOL < <(grep "gemini" "$TARGET_MYIP" | grep -oP '@\K[^?#\s]+' | grep ':')

        NORMAL_POOL_SIZE=${#NORMAL_IP_POOL[@]}
        GEMINI_POOL_SIZE=${#GEMINI_IP_POOL[@]}
        echo "::debug::IP Pool Check: Found $NORMAL_POOL_SIZE normal Addrs and $GEMINI_POOL_SIZE gemini Addrs."

        if [ "$NORMAL_POOL_SIZE" -eq 0 ]; then
          echo "::error::No valid addresses found in myIP.txt, keeping original."
          cp "$TARGET_MYDIZHI" "$OUTPUT_FILE"
          exit 0
        fi

        # 3. 初始化
        NORMAL_COUNTER=0
        GEMINI_COUNTER=0
        > "$OUTPUT_FILE"
        grep -E '^(vless|vmess|trojan)://' "$TARGET_MYDIZHI" > /tmp/nodes.txt

        echo "::debug::Starting node processing loop..."

        # 4. 处理每个节点
        while IFS= read -r line; do
          LINE_NUM=$((LINE_NUM+1))

          # 清理首尾空白和 Windows 换行符
          line=$(echo "$line" | tr -d '\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

          echo "::debug::--- Line $LINE_NUM: Start ---"
          
          # --- VMess 节点处理 ---
          if [[ "$line" =~ ^vmess:// ]]; then
            BASE64_STR=${line#vmess://}
            CLEAN_BASE64_STR=$(echo "$BASE64_STR" | tr -d '\r\n\t ' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            JSON_STR=$(echo "$CLEAN_BASE64_STR" | base64 -d 2>/dev/null || echo "")

            if [ -z "$JSON_STR" ]; then
              echo "::error::Line $LINE_NUM: VMess BASE64 decode failed."
              echo "$line" >> "$OUTPUT_FILE"
              continue
            fi

            if echo "$JSON_STR" | jq empty 2>/dev/null; then
              # --- 地址替换逻辑 ---
              # 判断使用哪个池
              if echo "$JSON_STR" | grep -q "gemini"; then
                # 使用 Gemini 池
                if [ "$GEMINI_POOL_SIZE" -gt 0 ]; then
                  POOL_ARRAY=("${GEMINI_IP_POOL[@]}")
                  IDX=$((GEMINI_COUNTER % GEMINI_POOL_SIZE))
                  GEMINI_COUNTER=$((GEMINI_COUNTER + 1))
                  USE_POOL="Gemini"
                else
                  # 回退或跳过
                  echo "$line" >> "$OUTPUT_FILE"
                  continue
                fi
              else
                # 使用普通池
                POOL_ARRAY=("${NORMAL_IP_POOL[@]}")
                IDX=$((NORMAL_COUNTER % NORMAL_POOL_SIZE))
                NORMAL_COUNTER=$((NORMAL_COUNTER + 1))
                USE_POOL="Normal"
              fi

              # 获取当前轮询到的地址串 (格式如 www.visa.com:443 或 1.1.1.1:80)
              CURRENT_PAIR="${POOL_ARRAY[$IDX]}"
              
              # 提取 Host 和 Port (利用 Bash 字符串操作分离最后一个冒号)
              NEW_IP=${CURRENT_PAIR%:*}
              NEW_PORT=${CURRENT_PAIR#*:}

              # 替换并重新编码 (jq 会自动处理字符串引号，所以域名和IP都适用)
              NEW_JSON=$(echo "$JSON_STR" | jq -c --arg ip "$NEW_IP" --arg port "$NEW_PORT" '.add = $ip | .port = $port')
              NEW_BASE64=$(echo -n "$NEW_JSON" | base64 -w 0)

              echo "vmess://$NEW_BASE64" >> "$OUTPUT_FILE"
              echo "::debug::Line $LINE_NUM: **$USE_POOL VMess Updated** -> Addr: $NEW_IP, Port: $NEW_PORT"

            else
              echo "::error::Line $LINE_NUM: VMess JSON parse failed."
              echo "$line" >> "$OUTPUT_FILE"
            fi

          # --- VLESS / Trojan 处理 ---
          elif [[ "$line" =~ ^(vless|trojan):// ]]; then
            PROTOCOL="${BASH_REMATCH[1]}"
            
            # 确定使用哪个池
            USE_POOL=""
            if echo "$line" | grep -q "gemini"; then
              if [ "$GEMINI_POOL_SIZE" -gt 0 ]; then
                  POOL_ARRAY=("${GEMINI_IP_POOL[@]}")
                  IDX=$((GEMINI_COUNTER % GEMINI_POOL_SIZE))
                  GEMINI_COUNTER=$((GEMINI_COUNTER + 1))
                  USE_POOL="Gemini"
              fi
            else
              POOL_ARRAY=("${NORMAL_IP_POOL[@]}")
              IDX=$((NORMAL_COUNTER % NORMAL_POOL_SIZE))
              NORMAL_COUNTER=$((NORMAL_COUNTER + 1))
              USE_POOL="Normal"
            fi

            # 如果确定了池，并且正则匹配原始链接成功，则进行替换
            # 正则说明：匹配 协议://UUID@原有Host:原有Port?参数
            if [ -n "$USE_POOL" ] && [[ "$line" =~ ^([a-z]+)://([^@]+)@([^:]+):([0-9]+)(.*)$ ]]; then
              USER_INFO="${BASH_REMATCH[2]}"
              REST_PARAMS="${BASH_REMATCH[5]}"
              
              # 获取新地址
              CURRENT_PAIR="${POOL_ARRAY[$IDX]}"
              NEW_IP=${CURRENT_PAIR%:*}
              NEW_PORT=${CURRENT_PAIR#*:}

              # 拼接新链接 (直接填入 NEW_IP，即使是域名也可以)
              echo "${PROTOCOL}://${USER_INFO}@${NEW_IP}:${NEW_PORT}${REST_PARAMS}" >> "$OUTPUT_FILE"
              echo "::debug::Line $LINE_NUM: **$USE_POOL ${PROTOCOL} Updated** -> Addr: $NEW_IP, Port: $NEW_PORT"
            else
              echo "::debug::Line $LINE_NUM: Skipping ${PROTOCOL} (No IP pool or Regex mismatch)"
              echo "$line" >> "$OUTPUT_FILE"
            fi

          else
            echo "::debug::Line $LINE_NUM: Not a node line, keeping original."
            echo "$line" >> "$OUTPUT_FILE"
          fi
          echo "::debug::--- Line $LINE_NUM: End ---"

        done < /tmp/nodes.txt

        # 5. 添加非节点内容和保存
        grep -vE '^(vless|vmess|trojan)://' "$TARGET_MYDIZHI" >> "$OUTPUT_FILE"
        mkdir -p "target-repo/${TARGET_FOLDER}"
        cp "$OUTPUT_FILE" "target-repo/${TARGET_FOLDER}/myDizhi_modified.txt"
        echo "::debug::Success! Processed myDizhi.txt with Domain/IP replacement"

    - name: Record End Time and Calculate Duration
      id: end_time
      run: |
        END_TIME=$(date +'%Y-%m-%d %H:%M:%S')
        START_SEC=$(date -d "${{ env.START_TIME }}" +%s)
        END_SEC=$(date -d "$END_TIME" +%s)
        DURATION=$((END_SEC - START_SEC))
        FORMATTED_DURATION=$(printf "%02d:%02d:%02d" $((DURATION/3600)) $((DURATION%3600/60)) $((DURATION%60)))
        echo "END_TIME=$END_TIME" >> $GITHUB_ENV
        echo "DURATION=$FORMATTED_DURATION" >> $GITHUB_ENV

    - name: Append Report Link to dizhiR.txt
      run: |
        # 读取时间戳文件
        declare -A timestamp_dates
        while IFS=: read -r key value; do
          timestamp_dates["$key"]="$value"
        done < "target-repo/${{ secrets.TARGET_FOLDER }}/timestamp.txt"

        # 计算时间差
        CURRENT_SEC=$(date +%s)
        get_days_diff() {
          local file_date="$1"
          local file_sec=$(date -d "$file_date" +%s)
          echo "scale=1; ($CURRENT_SEC - $file_sec)/86400" | bc -l | xargs printf "%.1f"
        }

        D1_DAYS=$(get_days_diff "${timestamp_dates[dizhi1.txt]}")
        D2_DAYS=$(get_days_diff "${timestamp_dates[dizhi2.txt]}")
        D3_DAYS=$(get_days_diff "${timestamp_dates[dizhi3.txt]}")

        # 生成报告链接
        echo "trojan://CMLiussss@127.0.0.1:8888?security=tls&allowInsecure=1&type=tcp&headerType=none#%23报告A ${{ env.START_TIME }} 耗时: ${{ env.DURATION }}" > target-repo/${{ secrets.TARGET_FOLDER }}/dizhiR.txt
        echo "trojan://CMLiussss@127.0.0.1:8888?security=tls&allowInsecure=1&type=tcp&headerType=none#%23报告A vm:${D1_DAYS} vl:${D2_DAYS} ss:${D3_DAYS}" >> target-repo/${{ secrets.TARGET_FOLDER }}/dizhiR.txt

    - name: Generate dizhi123.txt
      run: |
        {
          # 合并原有节点文件（每个文件只输出一次）
          cat target-repo/${{ secrets.TARGET_FOLDER }}/dizhi1.txt
          echo -e
          cat target-repo/${{ secrets.TARGET_FOLDER }}/dizhi2.txt
          echo -e
          cat target-repo/${{ secrets.TARGET_FOLDER }}/dizhi3.txt
          echo -e
          # 添加处理后的 myDizhi 节点（包含 IP 替换）
          if [ -f "target-repo/${{ secrets.TARGET_FOLDER }}/myDizhi_modified.txt" ]; then
            grep -E '^(vless|vmess|trojan)://' "target-repo/${{ secrets.TARGET_FOLDER }}/myDizhi_modified.txt"
            echo -e
          fi
          cat target-repo/${{ secrets.TARGET_FOLDER }}/dizhiR.txt
          echo -e
          
          # 新增：添加原始myDizhi.txt中的所有节点（包括gemini节点）
          if [ -f "target-repo/${{ secrets.TARGET_FOLDER }}/myDizhi.txt" ]; then
            echo "::debug::Processing updated myDizhi.txt"
            
            # 添加所有节点，包括gemini节点，不进行过滤
            grep -E '^(vless|vmess|trojan|ss|ssr)://' "target-repo/${{ secrets.TARGET_FOLDER }}/myDizhi.txt"
            echo "::debug::Extracted all nodes from modified myDizhi.txt (including gemini nodes)"
          fi
        } > target-repo/${{ secrets.TARGET_FOLDER }}/dizhi123.txt

    - name: Commit and Push changes
      run: |
        cd target-repo
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "github-actions-bot@users.noreply.github.com"
        
        git add .
        COMMIT_MESSAGE="Auto-update at ${{ env.END_TIME }}"
        if git commit -m "$COMMIT_MESSAGE"; then
          git push origin main
        else
          echo "::debug::No changes to commit"
        fi

    - name: Delete workflow runs
      uses: Mattraks/delete-workflow-runs@v2
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        repository: ${{ github.repository }}
        retain_days: 0
        keep_minimum_runs: 2
