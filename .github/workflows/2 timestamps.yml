name: 2 Time

on:
  schedule:
    - cron: '35 */8 * * *'  # 每8小时自动运行一次
  workflow_dispatch:        # 支持手动触发

concurrency:
  group: ${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  actions: write

jobs:
  update-nodes:
    runs-on: ubuntu-latest
    env:
      TZ: Asia/Shanghai  # 使用北京时间

    steps:
    - name: Checkout current repository
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
    
    - name: Record Start Time
      id: start_time
      run: |
        echo "START_TIME=$(date +'%Y-%m-%d %H:%M:%S')" >> $GITHUB_ENV
        echo "::debug::Start Time Recorded: ${{ env.START_TIME }}"

    - name: Fetch and Clean Webpage Content
      run: |
        VMESS_URL="${{ secrets.VMESS_URL }}"
        SS_URL="${{ secrets.SS_URL }}"
        
        echo "::debug::Fetching VMESS content from: $VMESS_URL" >&2
        curl -s "$VMESS_URL" | sed 's/<[^>]*>//g' > webpage_content.txt
        
        echo "::debug::Fetching SS content from: $SS_URL" >&2
        curl -s "$SS_URL" | sed 's/<[^>]*>//g' > ss_webpage_content.txt

    - name: Fetch and Update Nodes from Content Files
      run: |
        VMESS_NODES=$(grep -oP '.*vmess://\S+' webpage_content.txt | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/&amp;/\&/g' | sort -u)
        VLESS_NODES=$(grep -oP '.*vless://\S+' webpage_content.txt | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/&amp;/\&/g' | sort -u)
        SS_NODES=$(grep -oP '.*(ss://|ssr://)\S+' ss_webpage_content.txt | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/&amp;/\&/g' | sort -u)
        
        echo "$VMESS_NODES" > dizhi1.txt
        echo "$VLESS_NODES" > dizhi2.txt
        echo "$SS_NODES" > dizhi3.txt

    - name: Checkout target repository
      uses: actions/checkout@v4
      with:
        repository: ${{ secrets.TARGET_REPO }}
        token: ${{ secrets.TARGET_PAT }}
        path: target-repo
        fetch-depth: 0

    - name: Retrieve existing timestamp
      run: |
        if [ -f "target-repo/${{ secrets.TARGET_FOLDER }}/timestamp.txt" ]; then
          cp "target-repo/${{ secrets.TARGET_FOLDER }}/timestamp.txt" ./ || true
          echo "::debug::Copied existing timestamp file"
        else
          echo "::debug::No existing timestamp file found"
        fi

    - name: Update timestamp file
      run: |
        CURRENT_TIME=$(date +'%Y-%m-%d %H:%M:%S')
        declare -A timestamps
        
        # 读取现有时间戳
        if [ -f "timestamp.txt" ]; then
          while IFS=: read -r key value; do
            timestamps["$key"]="$value"
          done < timestamp.txt
        fi

        # 检查文件是否有变化
        check_diff() {
          local file="$1"
          local target_file="target-repo/${{ secrets.TARGET_FOLDER }}/$file"
          if [ -f "$target_file" ] && ! diff -q "$file" "$target_file" >/dev/null; then
            return 0
          else
            return 1
          fi
        }

        # 更新需要变更的时间戳
        for i in 1 2 3; do
          file="dizhi${i}.txt"
          if check_diff "$file"; then
            timestamps["$file"]="$CURRENT_TIME"
            echo "::debug::Updated timestamp for $file"
          elif [ -z "${timestamps[$file]}" ]; then
            timestamps["$file"]="$CURRENT_TIME"
            echo "::debug::Initialized timestamp for $file"
          fi
        done

        # 生成新的时间戳文件
        printf "dizhi1.txt:%s\n" "${timestamps[dizhi1.txt]}" > timestamp.txt
        printf "dizhi2.txt:%s\n" "${timestamps[dizhi2.txt]}" >> timestamp.txt
        printf "dizhi3.txt:%s\n" "${timestamps[dizhi3.txt]}" >> timestamp.txt

    - name: Copy files to target repository
      run: |
        cp -v dizhi*.txt ss_webpage_content.txt webpage_content.txt timestamp.txt "target-repo/${{ secrets.TARGET_FOLDER }}/"
        # 如果存在myIP.txt，也复制到目标目录
        if [ -f "target-repo/${{ secrets.TARGET_FOLDER }}/myIP.txt" ]; then
          cp -v "target-repo/${{ secrets.TARGET_FOLDER }}/myIP.txt" ./
        fi

    - name: Process myDizhi.txt with IP/Port Replacement (FIXED IPv6)
      run: |
        # 1. 定义路径和检查文件
        TARGET_FOLDER="${{ secrets.TARGET_FOLDER }}"
        TARGET_MYDIZHI="target-repo/${TARGET_FOLDER}/myDizhi.txt"
        TARGET_MYIP="target-repo/${TARGET_FOLDER}/myIP.txt"
        OUTPUT_FILE="myDizhi_modified.txt"

        if [ ! -f "$TARGET_MYDIZHI" ]; then
          echo "::error::myDizhi.txt not found at $TARGET_MYDIZHI, skipping."
          exit 0
        fi

        if [ ! -f "$TARGET_MYIP" ]; then
          echo "::error::myIP.txt not found, skipping replacement. File copied directly to output."
          cp "$TARGET_MYDIZHI" "$OUTPUT_FILE"
          exit 0
        fi

        # 2. 提取 IP/域名 池
        # 逻辑：匹配 @ 之后，直到遇到 ?、# 或行尾之前的非空字符。
        mapfile -t NORMAL_IP_POOL < <(grep -v "gemini" "$TARGET_MYIP" | grep -oP '@\K[^?#\s]+' | grep ':')
        mapfile -t GEMINI_IP_POOL < <(grep "gemini" "$TARGET_MYIP" | grep -oP '@\K[^?#\s]+' | grep ':')

        NORMAL_POOL_SIZE=${#NORMAL_IP_POOL[@]}
        GEMINI_POOL_SIZE=${#GEMINI_IP_POOL[@]}

        echo "::debug::IP Pool Check: Found $NORMAL_POOL_SIZE normal Addrs and $GEMINI_POOL_SIZE gemini Addrs."

        if [ "$NORMAL_POOL_SIZE" -eq 0 ]; then
          echo "::error::No valid addresses found in myIP.txt, keeping original."
          cp "$TARGET_MYDIZHI" "$OUTPUT_FILE"
          exit 0
        fi

        # 3. 初始化
        NORMAL_COUNTER=0
        GEMINI_COUNTER=0
        > "$OUTPUT_FILE"

        # 提取待处理节点
        grep -E '^(vless|vmess|trojan)://' "$TARGET_MYDIZHI" > /tmp/nodes.txt

        echo "::debug::Starting node processing loop..."

        # 4. 处理每个节点
        while IFS= read -r line; do
          LINE_NUM=$((LINE_NUM+1))

          # 清理首尾空白和 Windows 换行符
          line=$(echo "$line" | tr -d '\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

          echo "::debug::--- Line $LINE_NUM: Start ---"
          
          # --- VMess 节点处理 ---
          if [[ "$line" =~ ^vmess:// ]]; then
            BASE64_STR=${line#vmess://}
            # 修复 Base64 解码可能的填充问题
            CLEAN_BASE64_STR=$(echo "$BASE64_STR" | tr -d '\r\n\t ' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            JSON_STR=$(echo "$CLEAN_BASE64_STR" | base64 -d 2>/dev/null || echo "")

            if [ -z "$JSON_STR" ]; then
              echo "::error::Line $LINE_NUM: VMess BASE64 decode failed."
              echo "$line" >> "$OUTPUT_FILE"
              continue
            fi

            if echo "$JSON_STR" | jq empty 2>/dev/null; then
              # --- 地址替换逻辑 ---
              # 判断使用哪个池
              if echo "$JSON_STR" | grep -q "gemini"; then
                # 使用 Gemini 池
                if [ "$GEMINI_POOL_SIZE" -gt 0 ]; then
                  POOL_ARRAY=("${GEMINI_IP_POOL[@]}")
                  IDX=$((GEMINI_COUNTER % GEMINI_POOL_SIZE))
                  GEMINI_COUNTER=$((GEMINI_COUNTER + 1))
                  USE_POOL="Gemini"
                else
                  # 回退或跳过
                  echo "$line" >> "$OUTPUT_FILE"
                  continue
                fi
              else
                # 使用普通池
                POOL_ARRAY=("${NORMAL_IP_POOL[@]}")
                IDX=$((NORMAL_COUNTER % NORMAL_POOL_SIZE))
                NORMAL_COUNTER=$((NORMAL_COUNTER + 1))
                USE_POOL="Normal"
              fi

              # [关键修复] 获取新地址并正确分离端口
              CURRENT_PAIR="${POOL_ARRAY[$IDX]}"
              
              # 使用 ##*: 匹配最后一个冒号，确保 IPv6 [::1]:443 能正确提取 443
              NEW_PORT=${CURRENT_PAIR##*:}
              # 使用 %:* 删除最后一个冒号及其后的内容
              NEW_IP=${CURRENT_PAIR%:*}
              
              # [关键修复] VMess JSON 的 add 字段通常不需要方括号
              # 如果 NEW_IP 包含 []，则去掉，用于 JSON
              JSON_IP=$(echo "$NEW_IP" | tr -d '[]')

              NEW_JSON=$(echo "$JSON_STR" | jq -c --arg ip "$JSON_IP" --arg port "$NEW_PORT" '.add = $ip | .port = $port')
              NEW_BASE64=$(echo -n "$NEW_JSON" | base64 -w 0)
              echo "vmess://$NEW_BASE64" >> "$OUTPUT_FILE"
              echo "::debug::Line $LINE_NUM: **$USE_POOL VMess Updated** -> Addr: $NEW_IP, Port: $NEW_PORT"

            else
              echo "::error::Line $LINE_NUM: VMess JSON parse failed."
              echo "$line" >> "$OUTPUT_FILE"
            fi

          # --- VLESS / Trojan 处理 ---
          elif [[ "$line" =~ ^(vless|trojan):// ]]; then
            PROTOCOL="${BASH_REMATCH[1]}"
            
            # 确定使用哪个池
            USE_POOL=""
            if echo "$line" | grep -q "gemini"; then
              if [ "$GEMINI_POOL_SIZE" -gt 0 ]; then
                  POOL_ARRAY=("${GEMINI_IP_POOL[@]}")
                  IDX=$((GEMINI_COUNTER % GEMINI_POOL_SIZE))
                  GEMINI_COUNTER=$((GEMINI_COUNTER + 1))
                  USE_POOL="Gemini"
              fi
            else
              POOL_ARRAY=("${NORMAL_IP_POOL[@]}")
              IDX=$((NORMAL_COUNTER % NORMAL_POOL_SIZE))
              NORMAL_COUNTER=$((NORMAL_COUNTER + 1))
              USE_POOL="Normal"
            fi

            # [关键修复] 增强正则以支持 IPv6 作为目标节点
            # 旧正则: ([^:]+) 会在 IPv6 的冒号处断开
            # 新正则: 匹配 @ 之后，直到遇到 / ? # 之前的字符串作为 HOST:PORT 块
            if [ -n "$USE_POOL" ] && [[ "$line" =~ ^([a-z]+)://([^@]+)@([^/?#]+)(.*)$ ]]; then
              USER_INFO="${BASH_REMATCH[2]}"
              OLD_ADDR_BLOCK="${BASH_REMATCH[3]}"
              REST_PARAMS="${BASH_REMATCH[4]}"
              
              # 获取新地址
              CURRENT_PAIR="${POOL_ARRAY[$IDX]}"
              NEW_IP=${CURRENT_PAIR%:*}     # 这里保留方括号，如 [::1]
              NEW_PORT=${CURRENT_PAIR##*:}  # 这里使用 ## 修复端口提取

              # 拼接新链接 (VLESS URI 必须保留 IPv6 的方括号)
              echo "${PROTOCOL}://${USER_INFO}@${NEW_IP}:${NEW_PORT}${REST_PARAMS}" >> "$OUTPUT_FILE"
              echo "::debug::Line $LINE_NUM: **$USE_POOL ${PROTOCOL} Updated** -> Addr: $NEW_IP, Port: $NEW_PORT"
            else
              echo "::debug::Line $LINE_NUM: Skipping ${PROTOCOL} (No IP pool or Regex mismatch)"
              echo "$line" >> "$OUTPUT_FILE"
            fi

          else
            echo "::debug::Line $LINE_NUM: Not a node line, keeping original."
            echo "$line" >> "$OUTPUT_FILE"
          fi
          echo "::debug::--- Line $LINE_NUM: End ---"

        done < /tmp/nodes.txt

        # 5. 添加非节点内容和保存
        grep -vE '^(vless|vmess|trojan)://' "$TARGET_MYDIZHI" >> "$OUTPUT_FILE"
        mkdir -p "target-repo/${TARGET_FOLDER}"
        cp "$OUTPUT_FILE" "target-repo/${TARGET_FOLDER}/myDizhi_modified.txt"
        echo "::debug::Success! Processed myDizhi.txt with Domain/IP replacement (IPv6 Fixed)"

    - name: Save Start Time for Final Report
      run: |
        # 保存开始时间到文件，供工作流5使用
        echo "${{ env.START_TIME }}" > target-repo/${{ secrets.TARGET_FOLDER }}/workflow_start_time.txt

    - name: Commit and Push changes
      run: |
        cd target-repo
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "github-actions-bot@users.noreply.github.com"
        
        git add .
        COMMIT_MESSAGE="Auto-update at ${{ env.START_TIME }}: Node data collection started"
        if git commit -m "$COMMIT_MESSAGE"; then
          git push origin main
        else
          echo "::debug::No changes to commit"
        fi

    - name: Delete workflow runs
      uses: Mattraks/delete-workflow-runs@v2
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        repository: ${{ github.repository }}
        retain_days: 0
        keep_minimum_runs: 2
